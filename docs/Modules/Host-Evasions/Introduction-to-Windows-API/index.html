<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-Modules/Host-Evasions/Introduction-to-Windows-API" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">Introduction to Windows API - Windows API 简介 | TryHackMe CN Mirror</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Windows-API"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Introduction to Windows API - Windows API 简介 | TryHackMe CN Mirror"><meta data-rh="true" name="description" content="TryHackMe | Introduction to Windows API"><meta data-rh="true" property="og:description" content="TryHackMe | Introduction to Windows API"><link data-rh="true" rel="icon" href="/TryHackMe-CN/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Windows-API"><link data-rh="true" rel="alternate" href="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Windows-API" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://tryhackmyoffsecbox.github.io/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Windows-API" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/TryHackMe-CN/blog/rss.xml" title="TryHackMe CN Mirror RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/TryHackMe-CN/blog/atom.xml" title="TryHackMe CN Mirror Atom Feed"><link rel="stylesheet" href="/TryHackMe-CN/assets/css/styles.351040f8.css">
<script src="/TryHackMe-CN/assets/js/runtime~main.73b70cd6.js" defer="defer"></script>
<script src="/TryHackMe-CN/assets/js/main.e42e1732.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/TryHackMe-CN/"><div class="navbar__logo"><img src="/TryHackMe-CN/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/TryHackMe-CN/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Tryhackme CN Mirror</b></a><a class="navbar__item navbar__link" href="/TryHackMe-CN/docs/LearningPaths/">Learning Paths</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/TryHackMe-CN/docs/Modules/">Modules</a><a class="navbar__item navbar__link" href="/TryHackMe-CN/docs/Networks/">Networks</a><a class="navbar__item navbar__link" href="/TryHackMe-CN/blog">Blog</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/TryHackMe-CN/docs/Modules/">Modules</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/TryHackMe-CN/docs/Modules/Compromising-Active-Directory/">Compromising Active Directory - 妥协活动目录</a><button aria-label="展开侧边栏分类 &#x27;Compromising Active Directory - 妥协活动目录&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/TryHackMe-CN/docs/Modules/Host-Evasions/">Host Evasions - 主机规避</a><button aria-label="折叠侧边栏分类 &#x27;Host Evasions - 主机规避&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Abusing-Windows-Internals">Abusing Windows Internals</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Antivirus">Introduction to Antivirus</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Windows-API">Introduction to Windows API - Windows API 简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Windows-Internals">Windows Internals - Windows 内部机制</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/TryHackMe-CN/docs/Modules/Shells-and-Privilege-Escalation/">Shells and Privilege Escalation - Shell 和特权提升</a><button aria-label="展开侧边栏分类 &#x27;Shells and Privilege Escalation - Shell 和特权提升&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/TryHackMe-CN/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/TryHackMe-CN/docs/Modules/Host-Evasions/"><span itemprop="name">Host Evasions - 主机规避</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Introduction to Windows API - Windows API 简介</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Introduction to Windows API - Windows API 简介</h1>
<blockquote>
<p><a href="https://tryhackme.com/room/windowsapi" target="_blank" rel="noopener noreferrer">TryHackMe | Introduction to Windows API</a></p>
<p>Updated in 2023-12-28</p>
<p>学习如何与 Win32 API 进行交互，并理解其广泛的用例。</p>
<p>Learn how to interact with the win32 API and understand its wide range of use cases</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction---介绍">Introduction - 介绍<a href="#introduction---介绍" class="hash-link" aria-label="Introduction - 介绍的直接链接" title="Introduction - 介绍的直接链接"> ​</a></h2>
<p>Windows API 提供原生功能，用于与 Windows 操作系统的关键组件进行交互。该 API 被广泛应用于红队、威胁行为者、蓝队、软件开发人员和解决方案提供商之间。</p>
<p>该 API 能够与 Windows 系统无缝集成，提供各种用例。你可能会看到 Win32 API 被用于攻击性工具和恶意软件开发、EDR（终端检测与响应）工程以及一般软件应用。想了解更多关于 API 的所有用例，请查阅 Windows API 索引。</p>
<p>学习目标</p>
<ul>
<li>了解 Windows API 是什么，其用例以及与操作系统子系统的交互方式</li>
<li>学习如何在不同编程语言中实现 Windows API</li>
<li>了解从恶意角度使用 Windows API 的方式，并解析多个实际案例</li>
</ul>
<p>在开始学习本课程之前，我们建议具备对操作系统架构的一般了解。基本的编程知识也是推荐但非必需的。</p>
<p>本课程旨在基础层面教授 Windows API。我们会简要涵盖 Win32 API 的实现，但重点是理解 API 调用的原因和用途。</p>
<p>请系好安全带并确认最近的紧急出口位置（只是开玩笑罢了）</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="subsystem-and-hardware-interaction---子系统和硬件交互">Subsystem and Hardware Interaction - 子系统和硬件交互<a href="#subsystem-and-hardware-interaction---子系统和硬件交互" class="hash-link" aria-label="Subsystem and Hardware Interaction - 子系统和硬件交互的直接链接" title="Subsystem and Hardware Interaction - 子系统和硬件交互的直接链接">​</a></h2>
<p>程序经常需要访问或修改 Windows 子系统或硬件，但受到限制以维护机器的稳定性。为解决这个问题，微软发布了 Win32 API，这是一个用于在用户模式应用程序和内核之间进行接口的库。</p>
<p>Windows 将硬件访问区分为两种不同模式：用户模式（ <code>User mode</code> ）和内核模式（ <code>Kernel mode</code> ）。这些模式决定了应用程序或驱动程序被允许的硬件、内核和内存访问权限。API 或系统调用在每种模式之间进行接口，将信息发送到系统以在内核模式中进行处理。</p>
<table><thead><tr><th style="text-align:center">User mode</th><th style="text-align:center">Kernel mode</th></tr></thead><tbody><tr><td style="text-align:center">无直接硬件访问</td><td style="text-align:center">直接硬件访问</td></tr><tr><td style="text-align:center">访问 “拥有” 的内存位置</td><td style="text-align:center">访问整个物理内存</td></tr></tbody></table>
<p>有关内存管理的更多信息，请查阅 <code>Windows Internals</code> 。</p>
<p>以下是一个可视化展示，说明用户应用程序如何使用 API 调用来修改内核组件。</p>
<div style="text-align:center"><p><img loading="lazy" alt="Windows API 工作示例" src="/TryHackMe-CN/assets/images/image_20231218-141810-ee47107b9ffc80f9fb99a56e58e0c1a9.png" width="445" height="453" class="img_ev3q"></p></div>
<p>当观察语言与 Win32 API 交互的过程时，这个过程可能会变得更加扭曲；应用程序会在经过语言运行时之前再经过 API。</p>
<p>有关运行时的更多信息，请查阅 <code>Runtime Detection Evasion</code> 。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>用户模式下的进程是否具有直接硬件访问权限？(Y/N)</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">N</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以管理员权限启动应用程序是否会将进程置于内核模式下？(Y/N)</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">N</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="components-of-the-windows-api---windows-api-的组成部分">Components of the Windows API - Windows API 的组成部分<a href="#components-of-the-windows-api---windows-api-的组成部分" class="hash-link" aria-label="Components of the Windows API - Windows API 的组成部分的直接链接" title="Components of the Windows API - Windows API 的组成部分的直接链接">​</a></h2>
<p>Win32 API，更常被称为 Windows API，具有几个依赖组件，用于定义 API 的结构和组织。</p>
<p>让我们通过自顶向下的方法来分解 Win32 API。我们将假设 API 是顶层，构成特定调用的参数是底层。在下面的表格中，我们将以高层次描述自顶向下的结构，并稍后深入了解更多细节。</p>
<table><thead><tr><th style="text-align:center">Layer</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:center">API</td><td style="text-align:center">Win32 API 结构中用于描述任何调用的顶层 / 通用术语或理论。</td></tr><tr><td style="text-align:center">Header files or imports</td><td style="text-align:center">定义在运行时导入的库，由头文件或库导入文件定义。使用指针来获取函数地址。</td></tr><tr><td style="text-align:center">Core DLLs</td><td style="text-align:center">这是一组四个 DLL（动态链接库），用于定义调用结构。（KERNEL32、USER32 和 ADVAPI32）。这些 DLL 定义了不包含在单个子系统中的内核和用户服务。</td></tr><tr><td style="text-align:center">Supplemental DLLs</td><td style="text-align:center">作为 Windows API 的一部分定义的其他 DLL。控制 Windows 操作系统的各个独立子系统。还有约 36 个其他定义的 DLL（NTDLL、COM、FVEAPI 等）。</td></tr><tr><td style="text-align:center">Call Structures</td><td style="text-align:center">定义 API 调用本身以及调用的参数。</td></tr><tr><td style="text-align:center">API Calls</td><td style="text-align:center">程序中使用的 API 调用，函数地址是通过指针获取的。</td></tr><tr><td style="text-align:center">In/Out Parameters</td><td style="text-align:center">由调用结构定义的参数值。</td></tr></tbody></table>
<p>让我们扩展这些定义；在下一个任务中，我们将讨论导入库、核心头文件和调用结构。在第四个任务中，我们将更深入地了解调用，理解如何解析调用参数和变体。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>哪个头文件导入并定义了 User32 DLL 和结构？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">winuser.h</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>包含所有其他必需的子头文件和核心头文件的父头 文件是哪个？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">windows.h</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="os-libraries---操作系统库">OS Libraries - 操作系统库<a href="#os-libraries---操作系统库" class="hash-link" aria-label="OS Libraries - 操作系统库的直接链接" title="OS Libraries - 操作系统库的直接链接">​</a></h2>
<p>Win32 库中的每个 API 调用都驻留在内存中，并需要一个指向内存地址的指针。由于 ASLR（地址空间布局随机化）的实现，获取这些函数的指针的过程被模糊化；每种语言或包都有独特的过程来克服 ASLR。在整个教程中，我们将讨论两种最流行的实现方式：P/Invoke <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke" target="_blank" rel="noopener noreferrer">Platform Invoke (P/Invoke)</a> 和 Windows 头文件 <a href="https://learn.microsoft.com/en-us/windows/win32/winprog/using-the-windows-headers" target="_blank" rel="noopener noreferrer">Using the Windows Headers - Microsoft Learn</a>。</p>
<p>在这个任务中，我们将深入探讨这两种实现方式的工作原理，未来的任务中我们将把它们投入实际应用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="windows-头文件">Windows 头文件<a href="#windows-头文件" class="hash-link" aria-label="Windows 头文件的直接链接" title="Windows 头文件的直接链接">​</a></h3>
<p>微软发布了 Windows 头文件，也称为 Windows 加载器，作为解决 ASLR 实现相关问题的直接解决方案。在概念层面上，运行时加载器将确定正在进行的调用，并创建一个 thunk 表来获取函数地址或指针。</p>
<p>幸运的是，如果不希望深入了解，我们不必深入研究。</p>
<p>一旦将 <code>windows.h</code> 文件包含在未管理的程序的顶部，就可以调用任何 Win32 函数。</p>
<p>我们将在任务 6 中更实际地涵盖这个概念。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="pinvoke">P/Invoke<a href="#pinvoke" class="hash-link" aria-label="P/Invoke的直接链接" title="P/Invoke的直接链接">​</a></h3>
<p>微软将 P/Invoke 或平台调用描述为 “一种允许你从托管代码访问未管理库中的结构、回调和函数的技术。”</p>
<p>P/Invoke 提供了处理从托管代码调用未管理函数或者说调用 Win32 API 的整个过程的工具。P/Invoke 将从导入包含所需未管理函数或 Win32 API 调用的 DLL 开始。以下是导入 DLL 并提供选项的示例。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Runtime.InteropServices;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Program</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Unicode, SetLastError = true)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>在上面的代码中，我们使用属性 <code>DLLImport</code> 导入了 DLL <code>user32</code> 。</p>
<p>注意：这里没有包含分号，因为 P/Invoke 函数还没有完成。在第二步中，我们必须将一个托管方法定义为外部方法。<code>extern</code> 关键字将告知运行时先前导入的特定 DLL。以下是创建外部方法的示例。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">using System;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">using System.Runtime.InteropServices;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class Program</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern int MessageBox(IntPtr hWnd, string lpText, string lpCaption, uint uType);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>现在我们可以将这个函数作为托管方法调用，但实际上是在调用未管理的函数！</p>
<p>我们将在任务 7 中更实际地涵盖这个概念。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>提供给 .NET 的 P/Invoke 的主要命名空间是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">System</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>用于模糊导入 API 调用过程的内存保护解决方案是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ASLR</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="api-call-structure---api-调用结构">API Call Structure - API 调用结构<a href="#api-call-structure---api-调用结构" class="hash-link" aria-label="API Call Structure - API 调用结构的直接链接" title="API Call Structure - API 调用结构的直接链接">​</a></h2>
<p>API 调用是 Win32 库的第二个主要组成部分。这些调用提供了可扩展性和灵活性，可用于满足大量用例。大多数 Win32 API 调用都在 <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list" target="_blank" rel="noopener noreferrer">Windows API index - Microsoft Learn</a> 和 <a href="http://pinvoke.net/" target="_blank" rel="noopener noreferrer">pinvoke.net</a> 下有详细说明。</p>
<p>在这个任务中，我们将初步了解 API 调用的命名方案和输入 / 输出参数。</p>
<p>通过修改命名方案并附加表示字符，可以扩展 API 调用的功能。以下是 Microsoft 支持的命名方案字符表。</p>
<table><thead><tr><th style="text-align:center">Character</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">表示采用 ANSI 编码的 8 位字符集</td></tr><tr><td style="text-align:center">W</td><td style="text-align:center">表示 Unicode 编码</td></tr><tr><td style="text-align:center">Ex</td><td style="text-align:center">为 API 调用提供了扩展功能或输入 / 输出参数</td></tr></tbody></table>
<p>想要了解更多关于这个概念的信息，可以查阅 <a href="https://learn.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings" target="_blank" rel="noopener noreferrer">Working with Strings - Microsoft Learn</a> 。</p>
<hr>
<p>每个 API 调用还有预定义的结构来定义其输入 / 输出参数。你可以在 <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list" target="_blank" rel="noopener noreferrer">Windows API index - Microsoft Learn</a> 中相应 API 调用页面找到大多数这些结构，以及对每个 I/O 参数的解释。</p>
<p>让我们以 <code>WriteProcessMemory</code> API 调用为例。以下是该调用的 I/O 结构，可以在 <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory" target="_blank" rel="noopener noreferrer">WriteProcessMemory function (memoryapi.h)</a> 获取到。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BOOL </span><span class="token function" style="color:#d73a49">WriteProcessMemory</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">  HANDLE  hProcess</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">  LPVOID  lpBaseAddress</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">  LPCVOID lpBuffer</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">  SIZE_T  nSize</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">out</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> SIZE_T  </span><span class="token operator" style="color:#393A34">*</span><span class="token plain">lpNumberOfBytesWritten</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>对于每个 I/O 参数，微软也解释了其用途、预期输入或输出以及接受的值。</p>
<p>即使有解释，有时确定这些值对于特定调用也可能具有挑战性。我们建议在将调用用于代码之前，始终进行研究并查找 API 调用使用的示例。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>附加到 API 调用的字符中，表示 ANSI 编码的是哪个？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">A</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>附加到 API 调用的字符中，表示扩展功能的是  哪个？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Ex</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 VirtualAlloc API 调用中，0x00080000 的内存分配类型是什么？</p><details class="details_lb9f alert alert--info details_b_Ee" data-collapsed="true"><summary> 具体操作步骤 </summary><div><div class="collapsibleContent_i85q"><p>可以在以下文档中找到说明</p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc" target="_blank" rel="noopener noreferrer">VirtualAlloc function (memoryapi.h) - Microsoft Learn</a></p></div></div></details><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MEM_RESET</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="c-api-implementations---c-api-实现">C API Implementations - C API 实现<a href="#c-api-implementations---c-api-实现" class="hash-link" aria-label="C API Implementations - C API 实现的直接链接" title="C API Implementations - C API 实现的直接链接">​</a></h2>
<p>微软为诸如 C 和 C++ 这样的低级编程语言提供了预配置的一套库，我们可以使用这些库来访问所需的 API 调用。</p>
<p>正如在任务 4 中讨论的那样，windows.h 头文件用于定义调用结构并获取函数指针。要在任何 C 或 C++ 程序中包含 windows 头文件，请在程序开头添加以下行。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token macro property directive-hash" style="color:#36acaa">#</span><span class="token macro property directive keyword" style="color:#00009f">include</span><span class="token macro property" style="color:#36acaa"> </span><span class="token macro property string" style="color:#e3116c">&lt;windows.h&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制 代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>让我们直接开始创建我们的第一个 API 调用。作为我们的第一个目标，我们打算使用 CreateWindowExA 创建一个标题为：“Hello THM！” 的弹出窗口。为了重申任务 5 中讨论的内容，让我们观察一下该调用的输入 / 输出参数。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HWND </span><span class="token function" style="color:#d73a49">CreateWindowExA</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           DWORD     dwExStyle</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Optional windows styles</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> LPCSTR    lpClassName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Windows class</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> LPCSTR    lpWindowName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Windows text</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           DWORD     dwStyle</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Windows style</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain">       X</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// X position</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain">       Y</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Y position</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain">       nWidth</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Width size</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">           </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain">       nHeight</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Height size</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> HWND      hWndParent</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Parent windows</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> HMENU     hMenu</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Menu</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> HINSTANCE hInstance</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// Instance handle</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">in</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> optional</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> LPVOID    lpParam </span><span class="token comment" style="color:#999988;font-style:italic">// Additional application data</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>让我们拿这些预定义的参数并为它们赋值。正如在任务 5 中提到的，每个 API 调用的参数都有其用途和潜在值的解释。以下是对 <code>CreateWindowsExA</code> 的完整调用的示例。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">HWND hwnd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">CreateWindowsEx</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CLASS_NAME</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    L</span><span class="token string" style="color:#e3116c">&quot;Hello THM!&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WS_OVERLAPPEDWINDOW</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    hInstance</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token constant" style="color:#36acaa">NULL</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>我们已经在 C 中定义了我们的第一个 API 调用！现在我们可以将其实现到一个应用程序中，并使用这个 API 调用的功能。以下是一个使用 API 创建一个小型空白窗口的示例应用程序。</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">BOOL </span><span class="token function" style="color:#d73a49">Create</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        PCWSTR lpWindowName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DWORD dwStyle</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DWORD dwExStyle </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> x </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> y </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> nWidth </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">int</span><span class="token plain"> nHeight </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> CW_USEDEFAULT</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HWND hWndParent </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        HMENU hMenu </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WNDCLASS wc </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wc</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lpfnWndProc   </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> DERIVED_TYPE</span><span class="token operator" style="color:#393A34">::</span><span class="token plain">WindowProc</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wc</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">hInstance     </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">GetModuleHandle</span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wc</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lpszClassName </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ClassName</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token function" style="color:#d73a49">RegisterClass</span><span class="token punctuation" style="color:#393A34">(</span><span class="token operator" style="color:#393A34">&amp;</span><span class="token plain">wc</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m_hwnd </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">CreateWindowEx</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dwExStyle</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ClassName</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> lpWindowName</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> dwStyle</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> y</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nWidth</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> nHeight</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> hWndParent</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> hMenu</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">GetModuleHandle</span><span class="token punctuation" style="color:#393A34">(</span><span class="token constant" style="color:#36acaa">NULL</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> this</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">m_hwnd </span><span class="token operator" style="color:#393A34">?</span><span class="token plain"> TRUE </span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> FALSE</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果成功，我们应该会看到一个标题为 “Hello THM!” 的窗口。</p>
<p>正如本任务中所展示的，低级语言使得快速定义 API 调用变得非常容易。由于易用性和可扩展性，基于 C 的语言在威胁行为者和供应商中都非常流行。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>你需要在 C 语言中定义一个结构体来使用 API 调用吗？（Y/N）</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">N</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="net-and-powershell-api-implementations---net-和-powershell-api-实现">.NET and PowerShell API Implementations - .NET 和 PowerShell API 实现<a href="#net-and-powershell-api-implementations---net-和-powershell-api-实现" class="hash-link" aria-label=".NET and PowerShell API Implementations - .NET 和 PowerShell API 实现的直接链接" title=".NET and PowerShell API Implementations - .NET 和 PowerShell API 实现的直接链接">​</a></h2>
<p>正如在任务 4 中讨论的那样，P/Invoke 允许我们导入 DLL 并为 API 调用分配指针。</p>
<p>为了理解 P/Invoke 是如何实现的，让我们直接通过下面的示例来了解，并在之后讨论各个组成部分。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Win32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [DllImport(&quot;kernel32&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>该类函数存储了定义的 API 调用以及在所有未来方法中引用的定义。</p>
<p>存储 API 调用结构的库现在必须使用 <code>DllImport</code> 进行导入。被导入的 DLL 类似于头文件包，但要求您导入具有您寻找的 API 调用的特定 DLL。您可以参考 API 索引或 pinvoke.net 来确定特定 API 调用在 DLL 中的位置。</p>
<p>通过 DLL 导入，我们可以创建一个指向我们想要使用的 API 调用的新指针，通常由 <code>intPtr</code> 定义。与其他低级语言不同，您必须在指针中指定输入 / 输出参数结构。正如在任务 5 中讨论的那样，我们可以从 Windows 文档中找到所需 API 调用的输入 / 输出参数。</p>
<p>现在，我们可以将定义的 API 调用实现到一个应用程序中并使用其功能。以下是一个示例应用程序，使用 API 获取其运行设备的计算机名称和其他信息。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">class Win32 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    [DllImport(&quot;kernel32&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static extern IntPtr GetComputerNameA(StringBuilder lpBuffer, ref uint lpnSize);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void Main(string[] args) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool success;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder name = new StringBuilder(260);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    uint size = 260;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    success = GetComputerNameA(name, ref size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Console.WriteLine(name.ToString());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>如果成功，程序应返回当前设备的计算机名称。</p>
<p>现在我们已经介绍了如何在. NET 中完成这个任务，让我们看看如何将相同的语法调整为在 PowerShell 中使用。</p>
<p>定义 API 调用几乎与. NET 的实现相同，但我们需要创建一个方法而不是一个类，并添加一些额外的运算符。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token variable" style="color:#36acaa">$MethodDefinition</span><span class="token plain"> = @</span><span class="token string" style="color:#e3116c">&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    [DllImport(&quot;</span><span class="token plain">kernel32</span><span class="token string" style="color:#e3116c">&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    [DllImport(&quot;</span><span class="token plain">kernel32</span><span class="token string" style="color:#e3116c">&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    public static extern IntPtr GetModuleHandle(string lpModuleName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    [DllImport(&quot;</span><span class="token plain">kernel32</span><span class="token string" style="color:#e3116c">&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token string" style="color:#e3116c">&quot;</span><span class="token plain">@</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这些调用现在已经定义，但在它们可以初始化之前，PowerShell 需要进一步的步骤。我们必须在方法定义中为每个 Win32 DLL 的指针创建一个新类型。函数 <code>Add-Type</code> 将在 <code>/temp</code> 目录中放置一个临时文件，并使用 <code>csc.exe</code> 编译所需的函数。以下是该函数的示例用法。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token variable" style="color:#36acaa">$Kernel32</span><span class="token plain"> = </span><span class="token function" style="color:#d73a49">Add-Type</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain">MemberDefinition </span><span class="token variable" style="color:#36acaa">$MethodDefinition</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain">Name </span><span class="token string" style="color:#e3116c">&#x27;Kernel32&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain">NameSpace </span><span class="token string" style="color:#e3116c">&#x27;Win32&#x27;</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">-</span><span class="token plain">PassThru</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>现在我们可以使用以下语法进行所需的 API 调用。</p>
<div class="language-powershell codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-powershell codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token namespace" style="opacity:0.7">[Win32.Kernel32]</span><span class="token plain">::&lt;Imported Call&gt;</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>使用什么方法导入所需的 DLL？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DllImport</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用什么类型的方法来引用 API 调用来获取结构体？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">External</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="commonly-abused-api-calls---常被滥用的-api-调用">Commonly Abused API Calls - 常被滥用的 API 调用<a href="#commonly-abused-api-calls---常被滥用的-api-调用" class="hash-link" aria-label="Commonly Abused API Calls - 常被滥用的 API 调用的直接链接" title="Commonly Abused API Calls - 常被滥用的 API 调用的直接链接">​</a></h2>
<p>Win32 库中的多个 API 调用很容易被用于恶意活动。</p>
<p>有多个实体试图记录和整理所有具有恶意向量的可用 API 调用，包括 SANs 和 MalAPI.io。</p>
<p>尽管很多调用被滥用，但有些比其他更频繁地出现在野外。以下是一个按照一系列样本中频率组织的最常被滥用的 API 调用表格。</p>
<table><thead><tr><th style="text-align:center">API Call</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:center">LoadLibraryA</td><td style="text-align:center">将指定的 DLL 映射到调用进程的地址空间</td></tr><tr><td style="text-align:center">GetUserNameA</td><td style="text-align:center">获取与当前线程关联的用户名称</td></tr><tr><td style="text-align:center">GetComputerNameA</td><td style="text-align:center">获取本地计算机的 NetBIOS 或 DNS 名称</td></tr><tr><td style="text-align:center">GetVersionExA</td><td style="text-align:center">获取当前运行操作系统版本的信息</td></tr><tr><td style="text-align:center">GetModuleFileNameA</td><td style="text-align:center">获取指定模块和进程文件的完全限定路径</td></tr><tr><td style="text-align:center">GetStartupInfoA</td><td style="text-align:center">获取 STARTUPINFO 结构的内容（窗口站、桌面、标准句柄以及进程的外观）</td></tr><tr><td style="text-align:center">GetModuleHandle</td><td style="text-align:center">如果映射到调用进程的地址空间中，返回指定模块的模块句柄</td></tr><tr><td style="text-align:center">GetProcAddress</td><td style="text-align:center">返回指定导出 DLL 函数的地址</td></tr><tr><td style="text-align:center">VirtualProtect</td><td style="text-align:center">改变调用进程虚拟地址空间中内存区域的保护方式</td></tr></tbody></table>
<p>在接下来的任务中，我们将深入研究这些调用在两个恶意软件样本中是如何被滥用的案例研究。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>哪个 API 调用返回导出的 DLL 函数的地址？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GetProcAddress</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>哪个 API 调用将指定的 DLL 导入到调用进程的地址空间中？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LoadLibrary</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="malware-case-study---恶意软件案例研究">Malware Case Study - 恶意软件案例研  究<a href="#malware-case-study---恶意软件案例研究" class="hash-link" aria-label="Malware Case Study - 恶意软件案例研究的直接链接" title="Malware Case Study - 恶意软件案例研究的直接链接">​</a></h2>
<p>现在我们了解了 Win32 库和常被滥用的 API 调用的基本实现，让我们分析两个恶意软件样本，并观察它们的调用是如何交互的。</p>
<p>在这个任务中，我们将分析一个 C# 键盘记录器和 shellcode 启动器。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="键盘记录器">键盘记录器<a href="#键盘记录器" class="hash-link" aria-label="键盘记录器的直接链接" title="键盘记录器的直接链接">​</a></h3>
<p>要开始分析键盘记录器，我们需要收集它实现了哪些 API 调用和钩子。因为键盘记录器是用 C# 编写的，它必须使用 P/Invoke 来获取每个调用的指针。以下是恶意样本源代码中 P/Invoke 定义的片段。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelKeyboardProc lpfn, IntPtr hMod, uint dwThreadId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;user32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[return: MarshalAs(UnmanagedType.Bool)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern bool UnhookWindowsHookEx(IntPtr hhk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern IntPtr GetModuleHandle(string lpModuleName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static int WHKEYBOARDLL = 13;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;kernel32.dll&quot;, CharSet = CharSet.Auto, SetLastError = true)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern IntPtr GetCurrentProcess();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以下是每个 API 调用及其相应用途的解释。</p>
<table><thead><tr><th style="text-align:center">API Call</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:center">SetWindowsHookEx</td><td style="text-align:center">将内存钩子安装到钩子链中，以监视特定事件</td></tr><tr><td style="text-align:center">UnhookWindowsHookEx</td><td style="text-align:center">从钩子链中移除已安装的钩子</td></tr><tr><td style="text-align:center">GetModuleHandle</td><td style="text-align:center">返回映射到调用进程的地址空间中的模块的模块句柄</td></tr><tr><td style="text-align:center">GetCurrentProcess</td><td style="text-align:center">获取当前进程的伪句柄</td></tr></tbody></table>
<p>为了保持案例研究的道德完整性，我们不会涉及样本如何收集每次按键。我们将分析样本是如何在当前进程上设置钩子的。以下是恶意样本源代码中设置钩子部分的片段。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public static void Main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    _hookID = SetHook(_proc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Application.Run();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UnhookWindowsHookEx(_hookID);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Application.Exit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static IntPtr SetHook(LowLevelKeyboardProc proc) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    using (Process curProcess = Process.GetCurrentProcess()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return SetWindowsHookEx(WHKEYBOARDLL, proc, GetModuleHandle(curProcess.ProcessName), 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>了解键盘记录器的目标和过程，然后根据以上代码片段分配相应的 API 调用。</p>
<p>利用 <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list" target="_blank" rel="noopener noreferrer">Windows API index - Microsoft Learn</a> 和以上片段的上下文，开始分析键盘记录器，使用问题 1 到 4 作为指导，逐步研究样本。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="shellcode-启动器">Shellcode 启动器<a href="#shellcode-启动器" class="hash-link" aria-label="Shellcode 启动器的直接链接" title="Shellcode 启动器的直接链接">​</a></h3>
<p>对于 Shellcode 启动器，开始分析它所实现的 API 调用，这个过程应该与之前的案例研究类似。以下是恶意样本源代码中的 P/Invoke 定义片段。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">private static UInt32 MEM_COMMIT = 0x1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;kernel32&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;kernel32&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[DllImport(&quot;kernel32&quot;)]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, UInt32 lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>以下是每个 API 调用及其相应用途的解释。</p>
<table><thead><tr><th style="text-align:center">API Call</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:center">VirtualAlloc</td><td style="text-align:center">在调用进程的虚拟  地址空间中保留、提交或更改页面区域的状态。</td></tr><tr><td style="text-align:center">WaitForSingleObject</td><td style="text-align:center">等待直到指定的对象处于信号状态或超时时间到达</td></tr><tr><td style="text-align:center">CreateThread</td><td style="text-align:center">创建一个线程，在调用进程的虚拟地址空间内执行</td></tr></tbody></table>
<p>现在我们将分析 shellcode 是如何被写入并在内存中执行的。</p>
<div class="language-aspnet codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-aspnet codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IntPtr hThread = IntPtr.Zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">UInt32 threadId = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IntPtr pinfo = IntPtr.Zero;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">WaitForSingleObject(hThread, 0xFFFFFFFF);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>让我们了解 shellcode 执行的目标和流程，然后根据以上片段分配相应的 API 调用。</p>
<p>利用 <a href="https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list" target="_blank" rel="noopener noreferrer">Windows API index - Microsoft Learn</a> 和以上片段的上下文，开始分析 shellcode 启动器，使用问题 5 到 8 作为指南，逐步研究样本。</p>
<div class="theme-admonition theme-admonition-info admonition_xJq3 alert alert--info"><div class="admonitionHeading_Gvgb"><span class="admonitionIcon_Rf37"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>Answer the questions below</div><div class="admonitionContent_BuS1"><p>在键盘记录器示例中，使用了哪个 Win32 API 调用来获取当前进程的伪句柄？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GetCurrentProcess</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在键盘记录器示例中，使用了哪个 Win32 API 调用来在当前进程上设置钩子？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">SetWindowsHookEx</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在键盘记录器示例中，使用了哪个 Win32 API 调用来从伪句柄获取句柄？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">GetModuleHandle</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在键盘记录器示例中，使用了哪个 Win32 API 调用来取消在当前进程上的钩子？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">UnhookWindowsHookEx</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 shellcode 启动器示例中，用于为 shellcode 大小分配内存的 Win32 API 调用是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">VirtualAlloc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 shellcode 启动器示例中，用于将 shellcode 写入已分配内存部分的本地方法是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Marshal.Copy</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 shellcode 启动器示例中，用于创建新执行线程的 Win32 API 调用是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CreateThread</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 shellcode 启动器示例中，用于等待线程退出的 Win32 API 调用是什么？</p><div class="language-plaintext codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-plaintext codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">WaitForSingleObject</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion---结论">Conclusion - 结论<a href="#conclusion---结论" class="hash-link" aria-label="Conclusion - 结论的直接链接" title="Conclusion - 结论的直接链接">​</a></h2>
<p>这就是 Windows API 基础知识的结束。API 的功能和可扩展性有许多其他可能性和应用，在这个房间里我们没有提到。</p>
<p>Windows API 可以为你提供各种用例，而我们将在后续的红队路径和 TryHackMe 的其他房间中继续讨论和探索。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/CTF-Archives/Tryhackme-CN/edit/main/docs/Modules/Host-Evasions/Introduction-to-Windows-API.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Introduction-to-Antivirus"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Introduction to Antivirus</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/TryHackMe-CN/docs/Modules/Host-Evasions/Windows-Internals"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">Windows Internals - Windows 内部机制</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#introduction---介绍" class="table-of-contents__link toc-highlight">Introduction - 介绍</a></li><li><a href="#subsystem-and-hardware-interaction---子系统和硬件交互" class="table-of-contents__link toc-highlight">Subsystem and Hardware Interaction - 子系统和硬件交互</a></li><li><a href="#components-of-the-windows-api---windows-api-的组成部分" class="table-of-contents__link toc-highlight">Components of the Windows API - Windows API 的组成部分</a></li><li><a href="#os-libraries---操作系统库" class="table-of-contents__link toc-highlight">OS Libraries - 操作系统库</a><ul><li><a href="#windows-头文件" class="table-of-contents__link toc-highlight">Windows 头文件</a></li><li><a href="#pinvoke" class="table-of-contents__link toc-highlight">P/Invoke</a></li></ul></li><li><a href="#api-call-structure---api-调用结构" class="table-of-contents__link toc-highlight">API Call Structure - API 调用结构</a></li><li><a href="#c-api-implementations---c-api-实现" class="table-of-contents__link toc-highlight">C API Implementations - C API 实现</a></li><li><a href="#net-and-powershell-api-implementations---net-和-powershell-api-实现" class="table-of-contents__link toc-highlight">.NET and PowerShell API Implementations - .NET 和 PowerShell API 实现</a></li><li><a href="#commonly-abused-api-calls---常被滥用的-api-调用" class="table-of-contents__link toc-highlight">Commonly Abused API Calls - 常被滥用的 API 调用</a></li><li><a href="#malware-case-study---恶意软件案例研究" class="table-of-contents__link toc-highlight">Malware Case Study - 恶意软件案例研究</a><ul><li><a href="#键盘记录器" class="table-of-contents__link toc-highlight">  键盘记录器</a></li><li><a href="#shellcode-启动器" class="table-of-contents__link toc-highlight">Shellcode 启动器</a></li></ul></li><li><a href="#conclusion---结论" class="table-of-contents__link toc-highlight">Conclusion - 结论</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 Tryhackme CN Mirror Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>